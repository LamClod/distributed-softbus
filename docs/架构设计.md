# 架构设计详细文档

## 1. 网络抽象层（NAL - Network Abstraction Layer）

### 1.1 设计目标
屏蔽异构网络技术差异，为核心层提供统一的传输接口。

### 1.2 核心接口定义（Rust）

```rust
// src/network/mod.rs

use async_trait::async_trait;
use std::net::SocketAddr;
use std::time::Duration;

/// 传输类型枚举
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TransportType {
    BLE,           // 蓝牙低功耗
    WiFiDirect,    // Wi-Fi点对点
    Ethernet,      // 有线网络
    MDns,          // 局域网mDNS
}

/// 链路质量指标
#[derive(Debug, Clone)]
pub struct LinkQuality {
    pub rssi: i8,              // 信号强度 (dBm)
    pub latency: Duration,      // 延迟
    pub bandwidth: u64,         // 带宽 (bytes/s)
    pub packet_loss: f32,       // 丢包率 (0.0-1.0)
}

/// 设备标识
#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub struct DeviceId(pub String);

/// 虚拟通道特征（核心抽象）
#[async_trait]
pub trait VirtualChannel: Send + Sync {
    /// 发送数据
    async fn send(&self, data: &[u8]) -> Result<usize, ChannelError>;
    
    /// 接收数据
    async fn recv(&self, buf: &mut [u8]) -> Result<usize, ChannelError>;
    
    /// 获取链路质量
    fn quality(&self) -> LinkQuality;
    
    /// 获取传输类型
    fn transport_type(&self) -> TransportType;
    
    /// 获取远端设备ID
    fn peer_id(&self) -> &DeviceId;
    
    /// 关闭通道
    async fn close(&self) -> Result<(), ChannelError>;
}

/// 网络适配器特征
#[async_trait]
pub trait NetworkAdapter: Send + Sync {
    /// 启动适配器（开始监听/广播）
    async fn start(&self) -> Result<(), AdapterError>;
    
    /// 发现设备
    async fn discover(&self, timeout: Duration) -> Result<Vec<DeviceInfo>, AdapterError>;
    
    /// 连接到指定设备
    async fn connect(&self, device_id: &DeviceId) -> Result<Box<dyn VirtualChannel>, AdapterError>;
    
    /// 接受连接
    async fn accept(&self) -> Result<Box<dyn VirtualChannel>, AdapterError>;
    
    /// 停止适配器
    async fn stop(&self) -> Result<(), AdapterError>;
}

/// 设备信息
#[derive(Debug, Clone)]
pub struct DeviceInfo {
    pub id: DeviceId,
    pub name: String,
    pub device_type: DeviceType,
    pub capabilities: Vec<String>,
    pub rssi: i8,
}

#[derive(Debug, Clone)]
pub enum DeviceType {
    Phone,
    Tablet,
    Laptop,
    Watch,
    IoT,
}
```

### 1.3 BLE适配器实现（Rust + C# FFI）

#### Rust侧接口
```rust
// src/network/ble/mod.rs

use btleplug::api::{Central, Manager as _, Peripheral as _, ScanFilter};
use btleplug::platform::{Adapter, Manager};

pub struct BleAdapter {
    manager: Manager,
    adapter: Adapter,
    connections: Arc<DashMap<DeviceId, BleChannel>>,
}

#[async_trait]
impl NetworkAdapter for BleAdapter {
    async fn start(&self) -> Result<(), AdapterError> {
        // 开始BLE扫描与广播
        self.adapter.start_scan(ScanFilter::default()).await?;
        
        // 启动GATT服务器（用于接受连接）
        self.start_gatt_server().await?;
        
        Ok(())
    }
    
    async fn discover(&self, timeout: Duration) -> Result<Vec<DeviceInfo>, AdapterError> {
        tokio::time::sleep(timeout).await;
        
        let peripherals = self.adapter.peripherals().await?;
        let mut devices = Vec::new();
        
        for peripheral in peripherals {
            if let Some(props) = peripheral.properties().await? {
                let device_info = self.parse_advertisement(&props)?;
                devices.push(device_info);
            }
        }
        
        Ok(devices)
    }
    
    async fn connect(&self, device_id: &DeviceId) -> Result<Box<dyn VirtualChannel>, AdapterError> {
        // 查找外设
        let peripheral = self.find_peripheral(device_id).await?;
        
        // 建立连接
        peripheral.connect().await?;
        peripheral.discover_services().await?;
        
        // 创建虚拟通道
        let channel = BleChannel::new(peripheral, device_id.clone());
        self.connections.insert(device_id.clone(), channel.clone());
        
        Ok(Box::new(channel))
    }
}

/// BLE虚拟通道实现
pub struct BleChannel {
    peripheral: Peripheral,
    device_id: DeviceId,
    tx_characteristic: Characteristic,  // 发送特征
    rx_characteristic: Characteristic,  // 接收特征
    rx_queue: Arc<Mutex<VecDeque<Vec<u8>>>>,
}

#[async_trait]
impl VirtualChannel for BleChannel {
    async fn send(&self, data: &[u8]) -> Result<usize, ChannelError> {
        // BLE MTU限制，需要分片
        const MTU: usize = 512;
        let mut sent = 0;
        
        for chunk in data.chunks(MTU) {
            self.peripheral
                .write(&self.tx_characteristic, chunk, WriteType::WithResponse)
                .await?;
            sent += chunk.len();
        }
        
        Ok(sent)
    }
    
    async fn recv(&self, buf: &mut [u8]) -> Result<usize, ChannelError> {
        // 从接收队列读取
        let mut queue = self.rx_queue.lock().await;
        
        if let Some(packet) = queue.pop_front() {
            let len = packet.len().min(buf.len());
            buf[..len].copy_from_slice(&packet[..len]);
            Ok(len)
        } else {
            // 等待通知
            tokio::time::sleep(Duration::from_millis(10)).await;
            Err(ChannelError::WouldBlock)
        }
    }
    
    fn quality(&self) -> LinkQuality {
        LinkQuality {
            rssi: -60,  // 从peripheral获取
            latency: Duration::from_millis(50),
            bandwidth: 1_000_000,  // ~1 Mbps
            packet_loss: 0.01,
        }
    }
    
    fn transport_type(&self) -> TransportType {
        TransportType::BLE
    }
}
```

#### Windows C# BLE扩展（可选）
```csharp
// native/windows/BleAdapter.cs

using Windows.Devices.Bluetooth;
using Windows.Devices.Bluetooth.Advertisement;
using System.Runtime.InteropServices;

public class NativeBleAdapter
{
    private BluetoothLEAdvertisementWatcher watcher;
    
    [DllExport]
    public static void StartAdvertising(string deviceId, string serviceName)
    {
        var publisher = new BluetoothLEAdvertisementPublisher();
        
        // 构造广播数据
        var data = new BluetoothLEAdvertisementDataSection();
        data.DataType = 0xFF;  // Manufacturer Data
        data.Data = EncodeDeviceInfo(deviceId, serviceName);
        
        publisher.Advertisement.DataSections.Add(data);
        publisher.Start();
    }
    
    [DllExport]
    public static void StartScanning(Action<DeviceInfo> callback)
    {
        var watcher = new BluetoothLEAdvertisementWatcher();
        
        watcher.Received += (sender, args) =>
        {
            var device = ParseAdvertisement(args);
            callback(device);
        };
        
        watcher.Start();
    }
}
```

### 1.4 Wi-Fi Direct适配器（C++实现）

```cpp
// native/wifi/wifi_direct_adapter.h

#ifndef WIFI_DIRECT_ADAPTER_H
#define WIFI_DIRECT_ADAPTER_H

#include <string>
#include <vector>
#include <memory>

extern "C" {

struct WifiDirectDevice {
    char device_id[64];
    char device_name[128];
    int signal_strength;
};

struct WifiDirectHandle;

// 初始化Wi-Fi Direct
WifiDirectHandle* wifi_direct_init();

// 开始发现
int wifi_direct_discover(WifiDirectHandle* handle, WifiDirectDevice* devices, int max_count);

// 连接到设备（返回socket fd）
int wifi_direct_connect(WifiDirectHandle* handle, const char* device_id);

// 接受连接
int wifi_direct_accept(WifiDirectHandle* handle);

// 清理资源
void wifi_direct_cleanup(WifiDirectHandle* handle);

} // extern "C"

#endif
```

```cpp
// native/wifi/wifi_direct_adapter.cpp

#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.networking.proximity.h>
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <linux/wireless.h>
#endif

extern "C" {

WifiDirectHandle* wifi_direct_init() {
    auto handle = new WifiDirectHandle();
    
#ifdef _WIN32
    // 使用Windows WiFi Direct API
    // 初始化P2P设备
#else
    // 使用Linux wpa_supplicant P2P接口
    handle->wpa_ctrl = wpa_ctrl_open("wlan0");
#endif
    
    return handle;
}

int wifi_direct_connect(WifiDirectHandle* handle, const char* device_id) {
    // 建立P2P连接后返回TCP socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    
    struct sockaddr_in serv_addr;
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(8888);  // 软总线默认端口
    
    // 解析P2P对端IP并连接
    connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
    
    return sockfd;
}

} // extern "C"
```

#### Rust FFI绑定
```rust
// src/network/wifi/ffi.rs

use std::os::raw::{c_char, c_int};

#[repr(C)]
pub struct WifiDirectDevice {
    device_id: [c_char; 64],
    device_name: [c_char; 128],
    signal_strength: c_int,
}

#[link(name = "wifi_direct")]
extern "C" {
    fn wifi_direct_init() -> *mut std::ffi::c_void;
    fn wifi_direct_discover(
        handle: *mut std::ffi::c_void,
        devices: *mut WifiDirectDevice,
        max_count: c_int,
    ) -> c_int;
    fn wifi_direct_connect(handle: *mut std::ffi::c_void, device_id: *const c_char) -> c_int;
    fn wifi_direct_cleanup(handle: *mut std::ffi::c_void);
}

pub struct WifiDirectAdapter {
    handle: *mut std::ffi::c_void,
}

impl WifiDirectAdapter {
    pub fn new() -> Self {
        let handle = unsafe { wifi_direct_init() };
        Self { handle }
    }
    
    pub async fn connect(&self, device_id: &str) -> Result<TcpStream, Error> {
        let c_id = CString::new(device_id)?;
        let fd = unsafe { wifi_direct_connect(self.handle, c_id.as_ptr()) };
        
        if fd < 0 {
            return Err(Error::ConnectionFailed);
        }
        
        // 将fd转换为Rust的TcpStream
        let stream = unsafe { TcpStream::from_raw_fd(fd) };
        Ok(stream)
    }
}
```

---

## 2. 核心层架构

### 2.1 连接管理器（Connection Manager）

```rust
// src/core/connection_manager.rs

use dashmap::DashMap;
use tokio::sync::RwLock;

/// 连接管理器（管理所有虚拟通道）
pub struct ConnectionManager {
    /// 设备ID -> 虚拟通道映射
    channels: Arc<DashMap<DeviceId, Arc<dyn VirtualChannel>>>,
    
    /// 网络适配器列表
    adapters: Vec<Box<dyn NetworkAdapter>>,
    
    /// 传输仲裁器
    arbiter: Arc<TransportArbiter>,
}

impl ConnectionManager {
    pub fn new() -> Self {
        Self {
            channels: Arc::new(DashMap::new()),
            adapters: vec![
                Box::new(BleAdapter::new()),
                Box::new(WifiDirectAdapter::new()),
                Box::new(MdnsAdapter::new()),
            ],
            arbiter: Arc::new(TransportArbiter::new()),
        }
    }
    
    /// 启动所有适配器
    pub async fn start(&self) -> Result<()> {
        for adapter in &self.adapters {
            adapter.start().await?;
        }
        
        // 启动后台任务：持续发现设备
        self.spawn_discovery_task();
        
        Ok(())
    }
    
    /// 获取到指定设备的通道（自动建立连接）
    pub async fn get_channel(&self, device_id: &DeviceId) -> Result<Arc<dyn VirtualChannel>> {
        // 1. 检查是否已存在连接
        if let Some(channel) = self.channels.get(device_id) {
            return Ok(channel.clone());
        }
        
        // 2. 选择最优适配器建立连接
        let adapter = self.arbiter.select_adapter(device_id, &self.adapters).await?;
        let channel = adapter.connect(device_id).await?;
        
        // 3. 缓存连接
        let channel = Arc::from(channel);
        self.channels.insert(device_id.clone(), channel.clone());
        
        Ok(channel)
    }
    
    /// 后台发现任务
    fn spawn_discovery_task(&self) {
        let adapters = self.adapters.clone();
        let channels = self.channels.clone();
        
        tokio::spawn(async move {
            loop {
                for adapter in &adapters {
                    if let Ok(devices) = adapter.discover(Duration::from_secs(5)).await {
                        for device in devices {
                            // 触发设备发现事件
                            event::emit(Event::DeviceDiscovered(device));
                        }
                    }
                }
                
                tokio::time::sleep(Duration::from_secs(10)).await;
            }
        });
    }
}
```

### 2.2 传输仲裁器（Transport Arbiter）

```rust
// src/core/transport_arbiter.rs

/// 传输仲裁器：动态选择最优传输介质
pub struct TransportArbiter {
    /// 链路质量历史数据
    link_stats: Arc<RwLock<HashMap<DeviceId, Vec<LinkQuality>>>>,
}

impl TransportArbiter {
    /// 为目标设备选择最优适配器
    pub async fn select_adapter(
        &self,
        device_id: &DeviceId,
        adapters: &[Box<dyn NetworkAdapter>],
    ) -> Result<&Box<dyn NetworkAdapter>> {
        // 策略：
        // 1. 优先使用已建立的高质量连接
        // 2. 小数据包 (<1KB) -> BLE
        // 3. 大文件传输 -> Wi-Fi Direct
        // 4. 局域网优先使用mDNS/TCP
        
        let stats = self.link_stats.read().await;
        
        if let Some(history) = stats.get(device_id) {
            // 分析历史质量，选择最优
            let best_transport = history
                .last()
                .map(|q| self.score_quality(q))
                .unwrap_or(TransportType::BLE);
            
            adapters.iter()
                .find(|a| a.transport_type() == best_transport)
                .ok_or(Error::NoSuitableAdapter)
        } else {
            // 首次连接，优先尝试BLE（低功耗发现）
            Ok(&adapters[0])
        }
    }
    
    fn score_quality(&self, quality: &LinkQuality) -> TransportType {
        // 评分算法
        if quality.bandwidth > 10_000_000 {  // > 10 Mbps
            TransportType::WiFiDirect
        } else if quality.latency < Duration::from_millis(100) {
            TransportType::Ethernet
        } else {
            TransportType::BLE
        }
    }
    
    /// 动态切换链路（例如从BLE升级到Wi-Fi）
    pub async fn upgrade_channel(
        &self,
        device_id: &DeviceId,
        current: &dyn VirtualChannel,
    ) -> Result<Box<dyn VirtualChannel>> {
        // 检测当前链路质量
        let quality = current.quality();
        
        if quality.bandwidth < 1_000_000 && current.transport_type() == TransportType::BLE {
            // 尝试升级到Wi-Fi Direct
            let wifi_adapter = WifiDirectAdapter::new();
            let new_channel = wifi_adapter.connect(device_id).await?;
            
            // 通知对端切换（通过控制消息）
            current.send(&ControlMessage::SwitchTransport { 
                new_type: TransportType::WiFiDirect 
            }.encode()).await?;
            
            Ok(new_channel)
        } else {
            Ok(Box::new(current.clone()))
        }
    }
}
```

### 2.3 服务路由器（Service Router）

```rust
// src/core/service_router.rs

use std::collections::HashMap;
use serde::{Serialize, Deserialize};

/// 服务标识
#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize, Deserialize)]
pub struct ServiceId(pub String);

/// 服务元数据
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceMetadata {
    pub id: ServiceId,
    pub name: String,
    pub version: String,
    pub capabilities: Vec<String>,
    pub provider: DeviceId,
}

/// 服务路由表
pub struct ServiceRouter {
    /// 本地服务注册表
    local_services: Arc<DashMap<ServiceId, ServiceMetadata>>,
    
    /// 远程服务缓存 (ServiceId -> DeviceId)
    remote_services: Arc<DashMap<ServiceId, DeviceId>>,
    
    /// 连接管理器引用
    conn_manager: Arc<ConnectionManager>,
}

impl ServiceRouter {
    /// 注册本地服务
    pub fn register_service(&self, metadata: ServiceMetadata) -> Result<()> {
        self.local_services.insert(metadata.id.clone(), metadata.clone());
        
        // 向所有已连接设备广播服务
        self.broadcast_service_announcement(metadata);
        
        Ok(())
    }
    
    /// 发现远程服务
    pub async fn discover_service(&self, service_id: &ServiceId) -> Result<Vec<ServiceMetadata>> {
        // 1. 检查本地缓存
        if let Some(device_id) = self.remote_services.get(service_id) {
            return Ok(vec![self.query_service_metadata(device_id.value()).await?]);
        }
        
        // 2. 向所有连接的设备查询
        let mut results = Vec::new();
        let channels = self.conn_manager.channels.iter();
        
        for entry in channels {
            let device_id = entry.key();
            let channel = entry.value();
            
            // 发送查询请求
            let request = ServiceQueryRequest {
                service_id: service_id.clone(),
            };
            
            channel.send(&request.encode()).await?;
            
            // 等待响应（超时1秒）
            if let Ok(response) = timeout(Duration::from_secs(1), self.recv_response(channel)).await {
                if let Some(metadata) = response.metadata {
                    results.push(metadata);
                    self.remote_services.insert(service_id.clone(), device_id.clone());
                }
            }
        }
        
        Ok(results)
    }
    
    /// 路由RPC调用到目标设备
    pub async fn route_call(
        &self,
        service_id: &ServiceId,
        request: RpcRequest,
    ) -> Result<RpcResponse> {
        // 1. 查找服务提供者
        let device_id = self.remote_services
            .get(service_id)
            .ok_or(Error::ServiceNotFound)?;
        
        // 2. 获取通道
        let channel = self.conn_manager.get_channel(&device_id).await?;
        
        // 3. 发送RPC请求
        channel.send(&request.encode()).await?;
        
        // 4. 等待响应
        let mut buf = vec![0u8; 4096];
        let n = channel.recv(&mut buf).await?;
        
        // 5. 解析响应
        let response = RpcResponse::decode(&buf[..n])?;
        Ok(response)
    }
    
    fn broadcast_service_announcement(&self, metadata: ServiceMetadata) {
        let channels = self.conn_manager.channels.clone();
        
        tokio::spawn(async move {
            let announcement = ServiceAnnouncement { metadata };
            
            for entry in channels.iter() {
                let channel = entry.value();
                let _ = channel.send(&announcement.encode()).await;
            }
        });
    }
}
```

---

## 3. RPC引擎与IDL系统

### 3.1 IDL语法定义

```idl
// 服务接口定义语言 (softbus_idl)

namespace com.example;

// 分布式相机服务
service DistributedCameraService {
    version "1.0.0";
    
    // 拍照方法
    rpc TakePicture(TakePictureRequest) returns (TakePictureResponse);
    
    // 开始视频流
    rpc StartStream(StreamConfig) returns (stream VideoFrame);
    
    // 获取相机能力
    rpc GetCapabilities() returns (CameraCapabilities);
}

// 请求消息
message TakePictureRequest {
    int32 quality = 1;          // 图片质量 (0-100)
    string format = 2;           // 格式: "jpeg", "png"
    optional Rect crop_rect = 3; // 裁剪区域
}

// 响应消息
message TakePictureResponse {
    bytes image_data = 1;        // 图片数据
    int64 timestamp = 2;         // 时间戳
    ImageMetadata metadata = 3;  // EXIF等元数据
}

message CameraCapabilities {
    repeated string supported_formats = 1;
    repeated Resolution supported_resolutions = 2;
    bool has_flash = 3;
}
```

### 3.2 IDL编译器实现

```rust
// tools/idl_compiler/src/main.rs

use pest::Parser;
use pest_derive::Parser;

#[derive(Parser)]
#[grammar = "softbus_idl.pest"]
pub struct IdlParser;

/// IDL编译器主入口
pub struct IdlCompiler {
    output_dir: PathBuf,
}

impl IdlCompiler {
    pub fn compile(&self, idl_file: &Path) -> Result<()> {
        // 1. 解析IDL文件
        let input = std::fs::read_to_string(idl_file)?;
        let pairs = IdlParser::parse(Rule::service_definition, &input)?;
        
        // 2. 构建AST
        let service_def = self.build_ast(pairs)?;
        
        // 3. 生成Rust代码
        self.generate_rust_code(&service_def)?;
        
        // 4. 生成C#代码（可选）
        self.generate_csharp_code(&service_def)?;
        
        Ok(())
    }
    
    fn generate_rust_code(&self, service: &ServiceDefinition) -> Result<()> {
        // 生成Proxy（客户端代理）
        let proxy_code = self.codegen_proxy(service);
        std::fs::write(
            self.output_dir.join(format!("{}_proxy.rs", service.name)),
            proxy_code,
        )?;
        
        // 生成Stub（服务端桩）
        let stub_code = self.codegen_stub(service);
        std::fs::write(
            self.output_dir.join(format!("{}_stub.rs", service.name)),
            stub_code,
        )?;
        
        Ok(())
    }
    
    fn codegen_proxy(&self, service: &ServiceDefinition) -> String {
        format!(r#"
// 自动生成 - 请勿手动修改

use softbus::{{ServiceId, RpcRequest, RpcResponse, ServiceRouter}};
use async_trait::async_trait;

pub struct {service_name}Proxy {{
    router: Arc<ServiceRouter>,
    service_id: ServiceId,
}}

impl {service_name}Proxy {{
    pub fn new(router: Arc<ServiceRouter>) -> Self {{
        Self {{
            router,
            service_id: ServiceId("{service_id}".to_string()),
        }}
    }}
    
    {methods}
}}

{method_impls}
"#,
            service_name = service.name,
            service_id = service.id(),
            methods = self.generate_method_signatures(service),
            method_impls = self.generate_method_implementations(service),
        )
    }
    
    fn generate_method_implementations(&self, service: &ServiceDefinition) -> String {
        service.methods.iter().map(|method| {
            format!(r#"
    pub async fn {method_name}(&self, request: {request_type}) -> Result<{response_type}> {{
        let rpc_req = RpcRequest {{
            service_id: self.service_id.clone(),
            method_name: "{method_name}".to_string(),
            payload: request.encode_to_vec(),
        }};
        
        let rpc_resp = self.router.route_call(&self.service_id, rpc_req).await?;
        
        let response = {response_type}::decode(&rpc_resp.payload[..])?;
        Ok(response)
    }}
"#,
                method_name = method.name,
                request_type = method.request_type,
                response_type = method.response_type,
            )
        }).collect::<Vec<_>>().join("\n")
    }
}
```

### 3.3 生成的Proxy示例

```rust
// generated/distributed_camera_service_proxy.rs (自动生成)

use softbus::prelude::*;

pub struct DistributedCameraServiceProxy {
    router: Arc<ServiceRouter>,
    service_id: ServiceId,
}

impl DistributedCameraServiceProxy {
    pub fn new(router: Arc<ServiceRouter>) -> Self {
        Self {
            router,
            service_id: ServiceId("com.example.DistributedCameraService".to_string()),
        }
    }
    
    /// 拍照
    pub async fn take_picture(&self, request: TakePictureRequest) -> Result<TakePictureResponse> {
        let rpc_req = RpcRequest {
            service_id: self.service_id.clone(),
            method_name: "TakePicture".to_string(),
            payload: request.encode_to_vec(),
        };
        
        let rpc_resp = self.router.route_call(&self.service_id, rpc_req).await?;
        
        let response = TakePictureResponse::decode(&rpc_resp.payload[..])?;
        Ok(response)
    }
    
    /// 获取相机能力
    pub async fn get_capabilities(&self) -> Result<CameraCapabilities> {
        let rpc_req = RpcRequest {
            service_id: self.service_id.clone(),
            method_name: "GetCapabilities".to_string(),
            payload: vec![],
        };
        
        let rpc_resp = self.router.route_call(&self.service_id, rpc_req).await?;
        Ok(CameraCapabilities::decode(&rpc_resp.payload[..])?)
    }
}
```

### 3.4 生成的Stub示例

```rust
// generated/distributed_camera_service_stub.rs (自动生成)

use softbus::prelude::*;
use async_trait::async_trait;

#[async_trait]
pub trait DistributedCameraService: Send + Sync {
    async fn take_picture(&self, request: TakePictureRequest) -> Result<TakePictureResponse>;
    async fn get_capabilities(&self) -> Result<CameraCapabilities>;
}

pub struct DistributedCameraServiceStub<T: DistributedCameraService> {
    service: Arc<T>,
}

impl<T: DistributedCameraService> DistributedCameraServiceStub<T> {
    pub fn new(service: Arc<T>) -> Self {
        Self { service }
    }
    
    /// 处理RPC请求
    pub async fn handle_request(&self, request: RpcRequest) -> Result<RpcResponse> {
        match request.method_name.as_str() {
            "TakePicture" => {
                let req = TakePictureRequest::decode(&request.payload[..])?;
                let resp = self.service.take_picture(req).await?;
                
                Ok(RpcResponse {
                    payload: resp.encode_to_vec(),
                    error: None,
                })
            }
            
            "GetCapabilities" => {
                let resp = self.service.get_capabilities().await?;
                
                Ok(RpcResponse {
                    payload: resp.encode_to_vec(),
                    error: None,
                })
            }
            
            _ => Err(Error::MethodNotFound(request.method_name)),
        }
    }
}
```

---

## 4. 安全认证模块

### 4.1 设备身份验证

```rust
// src/core/security/auth.rs

use ring::signature::{self, KeyPair};
use ring::rand::SystemRandom;

pub struct SecurityManager {
    /// 设备私钥
    private_key: signature::Ed25519KeyPair,
    
    /// 信任的设备公钥列表
    trusted_devices: Arc<DashMap<DeviceId, Vec<u8>>>,
    
    /// TLS配置
    tls_config: Arc<rustls::ServerConfig>,
}

impl SecurityManager {
    /// 生成设备密钥对
    pub fn generate_keypair() -> Result<(Vec<u8>, Vec<u8>)> {
        let rng = SystemRandom::new();
        let pkcs8_bytes = signature::Ed25519KeyPair::generate_pkcs8(&rng)?;
        
        let key_pair = signature::Ed25519KeyPair::from_pkcs8(pkcs8_bytes.as_ref())?;
        let public_key = key_pair.public_key().as_ref().to_vec();
        
        Ok((pkcs8_bytes.as_ref().to_vec(), public_key))
    }
    
    /// 设备握手认证
    pub async fn authenticate_device(&self, device_id: &DeviceId, channel: &dyn VirtualChannel) -> Result<()> {
        // 1. 发送认证请求（包含自己的公钥）
        let auth_req = AuthRequest {
            device_id: self.get_local_device_id(),
            public_key: self.private_key.public_key().as_ref().to_vec(),
            timestamp: SystemTime::now(),
        };
        
        channel.send(&auth_req.encode()).await?;
        
        // 2. 接收对端认证响应
        let mut buf = vec![0u8; 1024];
        let n = channel.recv(&mut buf).await?;
        let auth_resp = AuthResponse::decode(&buf[..n])?;
        
        // 3. 验证对端签名
        let peer_public_key = signature::UnparsedPublicKey::new(
            &signature::ED25519,
            &auth_resp.public_key,
        );
        
        peer_public_key.verify(
            &auth_resp.challenge,
            &auth_resp.signature,
        )?;
        
        // 4. 添加到信任列表
        self.trusted_devices.insert(device_id.clone(), auth_resp.public_key);
        
        Ok(())
    }
    
    /// 创建TLS加密通道
    pub async fn wrap_tls(&self, stream: TcpStream) -> Result<rustls::ServerConnection> {
        let conn = rustls::ServerConnection::new(self.tls_config.clone())?;
        
        // 握手
        // ...
        
        Ok(conn)
    }
}
```

---

## 5. 数据流图

```
设备A (手机)                    设备B (平板)
┌─────────────┐                ┌─────────────┐
│   应用层     │                │   应用层     │
│ takePicture()│                │ [相机服务]   │
└──────┬──────┘                └──────▲──────┘
       │                               │
┌──────▼──────┐                ┌──────┴──────┐
│  Proxy层    │                │   Stub层    │
│ 序列化请求   │                │ 反序列化请求 │
└──────┬──────┘                └──────▲──────┘
       │                               │
┌──────▼──────────────────────────────┴──────┐
│           服务路由器 (Service Router)       │
│  查找服务 -> 设备B                          │
└──────┬──────────────────────────────▲──────┘
       │                               │
┌──────▼──────┐                ┌──────┴──────┐
│ 连接管理器   │                │ 连接管理器   │
│ getChannel(B)│                │ 监听连接     │
└──────┬──────┘                └──────▲──────┘
       │                               │
┌──────▼──────┐                ┌──────┴──────┐
│ 虚拟通道     │◄──────────────►│ 虚拟通道     │
│ (Wi-Fi P2P) │   网络传输      │ (Wi-Fi P2P) │
└─────────────┘                └─────────────┘
```

---

## 6. 性能优化策略

### 6.1 零拷贝传输
```rust
use bytes::{Bytes, BytesMut};

pub struct ZeroCopyChannel {
    inner: TcpStream,
}

impl ZeroCopyChannel {
    pub async fn send_zerocopy(&self, data: Bytes) -> Result<()> {
        // 使用sendfile系统调用（Linux）
        #[cfg(target_os = "linux")]
        {
            use nix::sys::sendfile::sendfile;
            // 直接从页缓存发送，避免用户空间拷贝
        }
        
        // Windows使用TransmitFile
        #[cfg(target_os = "windows")]
        {
            // ...
        }
        
        Ok(())
    }
}
```

### 6.2 连接池复用
```rust
pub struct ChannelPool {
    pools: DashMap<DeviceId, VecDeque<Box<dyn VirtualChannel>>>,
    max_idle: usize,
}

impl ChannelPool {
    pub async fn acquire(&self, device_id: &DeviceId) -> Result<Box<dyn VirtualChannel>> {
        // 从池中获取或创建新连接
        if let Some(mut pool) = self.pools.get_mut(device_id) {
            if let Some(channel) = pool.pop_front() {
                return Ok(channel);
            }
        }
        
        // 创建新连接...
    }
    
    pub async fn release(&self, device_id: DeviceId, channel: Box<dyn VirtualChannel>) {
        let mut pool = self.pools.entry(device_id).or_insert_with(VecDeque::new);
        
        if pool.len() < self.max_idle {
            pool.push_back(channel);
        }
        // 否则关闭连接
    }
}
```

### 6.3 批量序列化
```rust
pub struct BatchSerializer {
    buffer: BytesMut,
}

impl BatchSerializer {
    pub fn add_message<T: Message>(&mut self, msg: &T) {
        // 使用protobuf的delimited编码
        msg.encode_length_delimited(&mut self.buffer).unwrap();
    }
    
    pub fn flush(&mut self) -> Bytes {
        self.buffer.split().freeze()
    }
}
```

---

**下一步**: 参见 `实施指南.md` 获取详细的代码示例和部署步骤。
