# 技术实施指南

## 1. 环境准备

### 1.1 开发环境要求

#### Rust工具链
```bash
# 安装Rust (1.75+)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 添加目标平台
rustup target add x86_64-pc-windows-msvc
rustup target add x86_64-unknown-linux-gnu
rustup target add aarch64-linux-android

# 安装开发工具
cargo install cargo-watch cargo-expand cargo-edit
```

#### C/C++工具链
```bash
# Windows
choco install llvm cmake

# Linux
sudo apt install build-essential cmake clang libbluetooth-dev
```

#### .NET SDK (用于Windows BLE适配器)
```bash
# Windows
winget install Microsoft.DotNet.SDK.8

# 验证
dotnet --version  # 应该 >= 8.0
```

### 1.2 蓝牙权限配置

#### Windows
```xml
<!-- Package.appxmanifest -->
<Capabilities>
  <DeviceCapability Name="bluetooth"/>
  <DeviceCapability Name="radios"/>
</Capabilities>
```

#### Linux
```bash
# 添加当前用户到bluetooth组
sudo usermod -a -G bluetooth $USER

# 配置BlueZ权限
sudo setcap 'cap_net_raw,cap_net_admin+eip' $(which hcitool)
```

#### Android
```xml
<!-- AndroidManifest.xml -->
<uses-permission android:name="android.permission.BLUETOOTH"/>
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>
<uses-permission android:name="android.permission.BLUETOOTH_SCAN"/>
<uses-permission android:name="android.permission.BLUETOOTH_CONNECT"/>
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
```

---

## 2. 项目初始化

### 2.1 创建Cargo工作空间

```bash
# 创建项目根目录
mkdir distributed-softbus && cd distributed-softbus

# 初始化Cargo工作空间
cat > Cargo.toml << 'EOF'
[workspace]
members = [
    "softbus-core",
    "softbus-network",
    "softbus-idl-compiler",
    "softbus-examples",
]

resolver = "2"

[workspace.package]
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[workspace.dependencies]
tokio = { version = "1.35", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
async-trait = "0.1"
dashmap = "5.5"
bytes = "1.5"
prost = "0.12"
tonic = "0.11"
ring = "0.17"
rustls = "0.22"
thiserror = "1.0"
anyhow = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
EOF
```

### 2.2 创建核心模块

```bash
# 创建核心库
cargo new --lib softbus-core
cd softbus-core

# 更新Cargo.toml
cat > Cargo.toml << 'EOF'
[package]
name = "softbus-core"
version.workspace = true
edition.workspace = true

[dependencies]
tokio.workspace = true
async-trait.workspace = true
serde.workspace = true
serde_json.workspace = true
dashmap.workspace = true
bytes.workspace = true
thiserror.workspace = true
anyhow.workspace = true
tracing.workspace = true
prost.workspace = true

# 加密库
ring = "0.17"
rustls = "0.22"

# 时间处理
chrono = "0.4"

[dev-dependencies]
tokio-test = "0.4"
EOF
```

### 2.3 创建网络层模块

```bash
cd ..
cargo new --lib softbus-network

cat > softbus-network/Cargo.toml << 'EOF'
[package]
name = "softbus-network"
version.workspace = true
edition.workspace = true

[dependencies]
softbus-core = { path = "../softbus-core" }
tokio.workspace = true
async-trait.workspace = true
bytes.workspace = true
thiserror.workspace = true

# 跨平台BLE
btleplug = "0.11"

# mDNS服务发现
mdns-sd = "0.7"

# 网络工具
socket2 = "0.5"
nix = { version = "0.27", features = ["net"] }

[target.'cfg(windows)'.dependencies]
windows = { version = "0.52", features = [
    "Devices_Bluetooth",
    "Devices_Bluetooth_Advertisement",
    "Devices_Bluetooth_GenericAttributeProfile",
    "Devices_Radios",
    "Networking_Sockets",
] }

[target.'cfg(unix)'.dependencies]
libc = "0.2"
EOF
```

---

## 3. 核心代码实现

### 3.1 错误处理（Error Handling）

```rust
// softbus-core/src/error.rs

use thiserror::Error;

#[derive(Error, Debug)]
pub enum SoftbusError {
    #[error("Device not found: {0}")]
    DeviceNotFound(String),
    
    #[error("Service not found: {0}")]
    ServiceNotFound(String),
    
    #[error("Connection failed: {0}")]
    ConnectionFailed(String),
    
    #[error("Authentication failed: {0}")]
    AuthenticationFailed(String),
    
    #[error("Channel error: {0}")]
    ChannelError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(#[from] prost::DecodeError),
    
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
    
    #[error("Timeout")]
    Timeout,
}

pub type Result<T> = std::result::Result<T, SoftbusError>;
```

### 3.2 设备标识与服务ID

```rust
// softbus-core/src/types.rs

use serde::{Deserialize, Serialize};
use std::fmt;

/// 设备唯一标识
#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize, Deserialize)]
pub struct DeviceId(String);

impl DeviceId {
    pub fn new(id: impl Into<String>) -> Self {
        Self(id.into())
    }
    
    pub fn generate() -> Self {
        use ring::rand::{SystemRandom, SecureRandom};
        
        let rng = SystemRandom::new();
        let mut bytes = [0u8; 16];
        rng.fill(&mut bytes).unwrap();
        
        Self(hex::encode(bytes))
    }
    
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl fmt::Display for DeviceId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// 服务唯一标识
#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize, Deserialize)]
pub struct ServiceId(String);

impl ServiceId {
    pub fn new(id: impl Into<String>) -> Self {
        Self(id.into())
    }
    
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

/// 设备类型
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum DeviceType {
    Phone,
    Tablet,
    Laptop,
    Watch,
    TV,
    IoT,
}

/// 设备信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceInfo {
    pub id: DeviceId,
    pub name: String,
    pub device_type: DeviceType,
    pub capabilities: Vec<String>,
    pub rssi: i8,
}
```

### 3.3 虚拟通道trait定义

```rust
// softbus-core/src/channel.rs

use crate::types::DeviceId;
use crate::error::Result;
use async_trait::async_trait;
use std::time::Duration;

/// 传输类型
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TransportType {
    BLE,
    WiFiDirect,
    Ethernet,
    MDns,
}

/// 链路质量指标
#[derive(Debug, Clone)]
pub struct LinkQuality {
    pub rssi: i8,
    pub latency: Duration,
    pub bandwidth: u64,
    pub packet_loss: f32,
}

/// 虚拟通道特征
#[async_trait]
pub trait VirtualChannel: Send + Sync {
    /// 发送数据
    async fn send(&self, data: &[u8]) -> Result<usize>;
    
    /// 接收数据（阻塞直到有数据）
    async fn recv(&self, buf: &mut [u8]) -> Result<usize>;
    
    /// 非阻塞接收
    async fn try_recv(&self, buf: &mut [u8]) -> Result<Option<usize>>;
    
    /// 获取链路质量
    fn quality(&self) -> LinkQuality;
    
    /// 获取传输类型
    fn transport_type(&self) -> TransportType;
    
    /// 获取对端设备ID
    fn peer_id(&self) -> &DeviceId;
    
    /// 关闭通道
    async fn close(&self) -> Result<()>;
    
    /// 检查通道是否活跃
    fn is_active(&self) -> bool;
}
```

### 3.4 BLE适配器完整实现

```rust
// softbus-network/src/ble/adapter.rs

use btleplug::api::{Central, CentralEvent, Manager as _, Peripheral as _, ScanFilter};
use btleplug::platform::{Adapter, Manager, Peripheral};
use softbus_core::prelude::*;
use std::sync::Arc;
use tokio::sync::{mpsc, RwLock};
use dashmap::DashMap;

const SERVICE_UUID: &str = "6E400001-B5A3-F393-E0A9-E50E24DCCA9E";
const TX_CHAR_UUID: &str = "6E400002-B5A3-F393-E0A9-E50E24DCCA9E";
const RX_CHAR_UUID: &str = "6E400003-B5A3-F393-E0A9-E50E24DCCA9E";

pub struct BleAdapter {
    manager: Manager,
    adapter: Arc<RwLock<Adapter>>,
    channels: Arc<DashMap<DeviceId, Arc<BleChannel>>>,
    event_tx: mpsc::Sender<CentralEvent>,
}

impl BleAdapter {
    pub async fn new() -> Result<Self> {
        let manager = Manager::new().await?;
        
        let adapters = manager.adapters().await?;
        let adapter = adapters.into_iter().next()
            .ok_or(SoftbusError::DeviceNotFound("No BLE adapter".into()))?;
        
        let (event_tx, mut event_rx) = mpsc::channel(100);
        
        let ble_adapter = Self {
            manager,
            adapter: Arc::new(RwLock::new(adapter)),
            channels: Arc::new(DashMap::new()),
            event_tx,
        };
        
        // 启动事件处理任务
        let channels = ble_adapter.channels.clone();
        tokio::spawn(async move {
            while let Some(event) = event_rx.recv().await {
                match event {
                    CentralEvent::DeviceDiscovered(id) => {
                        tracing::info!("BLE device discovered: {:?}", id);
                    }
                    CentralEvent::DeviceDisconnected(id) => {
                        tracing::warn!("BLE device disconnected: {:?}", id);
                        // 清理通道
                    }
                    _ => {}
                }
            }
        });
        
        Ok(ble_adapter)
    }
    
    pub async fn start(&self) -> Result<()> {
        let adapter = self.adapter.read().await;
        
        // 开始扫描
        adapter.start_scan(ScanFilter::default()).await
            .map_err(|e| SoftbusError::ConnectionFailed(e.to_string()))?;
        
        tracing::info!("BLE adapter started");
        Ok(())
    }
    
    pub async fn discover(&self, timeout: Duration) -> Result<Vec<DeviceInfo>> {
        tokio::time::sleep(timeout).await;
        
        let adapter = self.adapter.read().await;
        let peripherals = adapter.peripherals().await
            .map_err(|e| SoftbusError::ConnectionFailed(e.to_string()))?;
        
        let mut devices = Vec::new();
        
        for peripheral in peripherals {
            if let Ok(Some(properties)) = peripheral.properties().await {
                if let Some(local_name) = properties.local_name {
                    let device_info = DeviceInfo {
                        id: DeviceId::new(properties.address.to_string()),
                        name: local_name,
                        device_type: DeviceType::Phone, // 从广播数据解析
                        capabilities: vec!["ble".to_string()],
                        rssi: properties.rssi.unwrap_or(-100) as i8,
                    };
                    
                    devices.push(device_info);
                }
            }
        }
        
        Ok(devices)
    }
    
    pub async fn connect(&self, device_id: &DeviceId) -> Result<Arc<dyn VirtualChannel>> {
        // 查找外设
        let adapter = self.adapter.read().await;
        let peripherals = adapter.peripherals().await
            .map_err(|e| SoftbusError::ConnectionFailed(e.to_string()))?;
        
        let peripheral = peripherals.into_iter()
            .find(|p| {
                p.properties()
                    .now_or_never()
                    .and_then(|r| r.ok())
                    .flatten()
                    .map(|props| props.address.to_string() == device_id.as_str())
                    .unwrap_or(false)
            })
            .ok_or_else(|| SoftbusError::DeviceNotFound(device_id.to_string()))?;
        
        // 建立连接
        peripheral.connect().await
            .map_err(|e| SoftbusError::ConnectionFailed(e.to_string()))?;
        
        // 发现服务
        peripheral.discover_services().await
            .map_err(|e| SoftbusError::ConnectionFailed(e.to_string()))?;
        
        // 查找特征
        let chars = peripheral.characteristics();
        let tx_char = chars.iter()
            .find(|c| c.uuid.to_string() == TX_CHAR_UUID)
            .ok_or_else(|| SoftbusError::ConnectionFailed("TX characteristic not found".into()))?;
        
        let rx_char = chars.iter()
            .find(|c| c.uuid.to_string() == RX_CHAR_UUID)
            .ok_or_else(|| SoftbusError::ConnectionFailed("RX characteristic not found".into()))?;
        
        // 订阅通知
        peripheral.subscribe(rx_char).await
            .map_err(|e| SoftbusError::ConnectionFailed(e.to_string()))?;
        
        // 创建虚拟通道
        let channel = Arc::new(BleChannel::new(
            peripheral,
            device_id.clone(),
            tx_char.clone(),
            rx_char.clone(),
        ));
        
        self.channels.insert(device_id.clone(), channel.clone());
        
        Ok(channel as Arc<dyn VirtualChannel>)
    }
}
```

### 3.5 BLE通道实现

```rust
// softbus-network/src/ble/channel.rs

use btleplug::api::{Characteristic, Peripheral as _, WriteType};
use btleplug::platform::Peripheral;
use softbus_core::prelude::*;
use tokio::sync::Mutex;
use std::collections::VecDeque;

pub struct BleChannel {
    peripheral: Peripheral,
    device_id: DeviceId,
    tx_char: Characteristic,
    rx_char: Characteristic,
    rx_queue: Arc<Mutex<VecDeque<Vec<u8>>>>,
}

impl BleChannel {
    pub fn new(
        peripheral: Peripheral,
        device_id: DeviceId,
        tx_char: Characteristic,
        rx_char: Characteristic,
    ) -> Self {
        let rx_queue = Arc::new(Mutex::new(VecDeque::new()));
        
        // 启动接收任务
        let queue = rx_queue.clone();
        let p = peripheral.clone();
        let rx = rx_char.clone();
        
        tokio::spawn(async move {
            let mut notification_stream = p.notifications().await.unwrap();
            
            while let Some(data) = notification_stream.next().await {
                if data.uuid == rx.uuid {
                    let mut q = queue.lock().await;
                    q.push_back(data.value);
                }
            }
        });
        
        Self {
            peripheral,
            device_id,
            tx_char,
            rx_char,
            rx_queue,
        }
    }
}

#[async_trait]
impl VirtualChannel for BleChannel {
    async fn send(&self, data: &[u8]) -> Result<usize> {
        const BLE_MTU: usize = 512;
        let mut sent = 0;
        
        for chunk in data.chunks(BLE_MTU) {
            self.peripheral
                .write(&self.tx_char, chunk, WriteType::WithResponse)
                .await
                .map_err(|e| SoftbusError::ChannelError(e.to_string()))?;
            
            sent += chunk.len();
        }
        
        Ok(sent)
    }
    
    async fn recv(&self, buf: &mut [u8]) -> Result<usize> {
        loop {
            let mut queue = self.rx_queue.lock().await;
            
            if let Some(packet) = queue.pop_front() {
                let len = packet.len().min(buf.len());
                buf[..len].copy_from_slice(&packet[..len]);
                return Ok(len);
            }
            
            drop(queue);
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
    }
    
    async fn try_recv(&self, buf: &mut [u8]) -> Result<Option<usize>> {
        let mut queue = self.rx_queue.lock().await;
        
        if let Some(packet) = queue.pop_front() {
            let len = packet.len().min(buf.len());
            buf[..len].copy_from_slice(&packet[..len]);
            Ok(Some(len))
        } else {
            Ok(None)
        }
    }
    
    fn quality(&self) -> LinkQuality {
        LinkQuality {
            rssi: -60,
            latency: Duration::from_millis(50),
            bandwidth: 1_000_000,
            packet_loss: 0.01,
        }
    }
    
    fn transport_type(&self) -> TransportType {
        TransportType::BLE
    }
    
    fn peer_id(&self) -> &DeviceId {
        &self.device_id
    }
    
    async fn close(&self) -> Result<()> {
        self.peripheral.disconnect().await
            .map_err(|e| SoftbusError::ChannelError(e.to_string()))
    }
    
    fn is_active(&self) -> bool {
        self.peripheral.is_connected().now_or_never()
            .and_then(|r| r.ok())
            .unwrap_or(false)
    }
}
```

---

## 4. 服务发现实现

### 4.1 服务注册表

```rust
// softbus-core/src/service/registry.rs

use crate::types::{DeviceId, ServiceId};
use dashmap::DashMap;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceMetadata {
    pub id: ServiceId,
    pub name: String,
    pub version: String,
    pub capabilities: Vec<String>,
    pub provider: DeviceId,
}

pub struct ServiceRegistry {
    local_services: Arc<DashMap<ServiceId, ServiceMetadata>>,
    remote_services: Arc<DashMap<ServiceId, Vec<DeviceId>>>,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self {
            local_services: Arc::new(DashMap::new()),
            remote_services: Arc::new(DashMap::new()),
        }
    }
    
    /// 注册本地服务
    pub fn register(&self, metadata: ServiceMetadata) -> Result<()> {
        tracing::info!("Registering service: {}", metadata.id.as_str());
        self.local_services.insert(metadata.id.clone(), metadata);
        Ok(())
    }
    
    /// 注销服务
    pub fn unregister(&self, service_id: &ServiceId) -> Result<()> {
        self.local_services.remove(service_id);
        Ok(())
    }
    
    /// 查询本地服务
    pub fn get_local(&self, service_id: &ServiceId) -> Option<ServiceMetadata> {
        self.local_services.get(service_id).map(|r| r.clone())
    }
    
    /// 添加远程服务
    pub fn add_remote(&self, service_id: ServiceId, provider: DeviceId) {
        self.remote_services
            .entry(service_id)
            .or_insert_with(Vec::new)
            .push(provider);
    }
    
    /// 查询远程服务提供者
    pub fn get_providers(&self, service_id: &ServiceId) -> Vec<DeviceId> {
        self.remote_services
            .get(service_id)
            .map(|r| r.clone())
            .unwrap_or_default()
    }
    
    /// 列出所有本地服务
    pub fn list_local(&self) -> Vec<ServiceMetadata> {
        self.local_services
            .iter()
            .map(|r| r.value().clone())
            .collect()
    }
}
```

### 4.2 服务路由器

```rust
// softbus-core/src/service/router.rs

use super::registry::{ServiceRegistry, ServiceMetadata};
use crate::types::{DeviceId, ServiceId};
use crate::channel::VirtualChannel;
use crate::connection::ConnectionManager;
use crate::rpc::{RpcRequest, RpcResponse};
use std::sync::Arc;
use tokio::time::timeout;

pub struct ServiceRouter {
    registry: Arc<ServiceRegistry>,
    conn_manager: Arc<ConnectionManager>,
}

impl ServiceRouter {
    pub fn new(
        registry: Arc<ServiceRegistry>,
        conn_manager: Arc<ConnectionManager>,
    ) -> Self {
        Self {
            registry,
            conn_manager,
        }
    }
    
    /// 发现服务（本地+远程）
    pub async fn discover(&self, service_id: &ServiceId) -> Result<Vec<ServiceMetadata>> {
        let mut results = Vec::new();
        
        // 1. 查询本地
        if let Some(metadata) = self.registry.get_local(service_id) {
            results.push(metadata);
        }
        
        // 2. 查询远程（广播查询）
        let channels = self.conn_manager.get_all_channels();
        
        for (device_id, channel) in channels {
            let query = ServiceQuery {
                service_id: service_id.clone(),
            };
            
            // 发送查询
            if channel.send(&bincode::serialize(&query)?).await.is_ok() {
                // 等待响应
                if let Ok(Ok(response)) = timeout(
                    Duration::from_secs(1),
                    self.recv_query_response(channel.as_ref()),
                ).await {
                    if let Some(metadata) = response.metadata {
                        results.push(metadata);
                        self.registry.add_remote(service_id.clone(), device_id);
                    }
                }
            }
        }
        
        Ok(results)
    }
    
    /// 路由RPC调用
    pub async fn route_call(
        &self,
        service_id: &ServiceId,
        request: RpcRequest,
    ) -> Result<RpcResponse> {
        // 1. 获取服务提供者
        let providers = self.registry.get_providers(service_id);
        
        if providers.is_empty() {
            return Err(SoftbusError::ServiceNotFound(service_id.as_str().to_string()));
        }
        
        // 2. 选择提供者（简单策略：第一个）
        let provider = &providers[0];
        
        // 3. 获取通道
        let channel = self.conn_manager.get_channel(provider).await?;
        
        // 4. 发送请求
        let request_bytes = bincode::serialize(&request)?;
        channel.send(&request_bytes).await?;
        
        // 5. 接收响应
        let mut buf = vec![0u8; 65536];
        let n = channel.recv(&mut buf).await?;
        
        // 6. 解析响应
        let response: RpcResponse = bincode::deserialize(&buf[..n])?;
        Ok(response)
    }
    
    async fn recv_query_response(&self, channel: &dyn VirtualChannel) -> Result<ServiceQueryResponse> {
        let mut buf = vec![0u8; 4096];
        let n = channel.recv(&mut buf).await?;
        Ok(bincode::deserialize(&buf[..n])?)
    }
}

#[derive(Serialize, Deserialize)]
struct ServiceQuery {
    service_id: ServiceId,
}

#[derive(Serialize, Deserialize)]
struct ServiceQueryResponse {
    metadata: Option<ServiceMetadata>,
}
```

---

## 5. RPC引擎实现

### 5.1 RPC协议定义（Protobuf）

```protobuf
// proto/rpc.proto

syntax = "proto3";

package softbus.rpc;

message RpcRequest {
    string request_id = 1;
    string service_id = 2;
    string method_name = 3;
    bytes payload = 4;
    int64 timestamp = 5;
}

message RpcResponse {
    string request_id = 1;
    oneof result {
        bytes payload = 2;
        RpcError error = 3;
    }
    int64 timestamp = 4;
}

message RpcError {
    int32 code = 1;
    string message = 2;
}
```

### 5.2 RPC客户端

```rust
// softbus-core/src/rpc/client.rs

use prost::Message;
use crate::service::router::ServiceRouter;
use crate::types::ServiceId;
use std::sync::Arc;
use uuid::Uuid;

include!(concat!(env!("OUT_DIR"), "/softbus.rpc.rs"));

pub struct RpcClient {
    router: Arc<ServiceRouter>,
}

impl RpcClient {
    pub fn new(router: Arc<ServiceRouter>) -> Self {
        Self { router }
    }
    
    pub async fn call(
        &self,
        service_id: &ServiceId,
        method_name: &str,
        payload: Vec<u8>,
    ) -> Result<Vec<u8>> {
        let request = RpcRequest {
            request_id: Uuid::new_v4().to_string(),
            service_id: service_id.as_str().to_string(),
            method_name: method_name.to_string(),
            payload,
            timestamp: chrono::Utc::now().timestamp_millis(),
        };
        
        let response = self.router.route_call(service_id, request).await?;
        
        match response.result {
            Some(rpc_response::Result::Payload(data)) => Ok(data),
            Some(rpc_response::Result::Error(err)) => {
                Err(SoftbusError::ConnectionFailed(err.message))
            }
            None => Err(SoftbusError::ConnectionFailed("Empty response".into())),
        }
    }
}
```

---

## 6. 完整使用示例

### 6.1 定义服务接口（IDL）

```idl
// examples/camera_service.idl

service CameraService {
    version "1.0.0";
    
    rpc TakePicture(TakePictureRequest) returns (TakePictureResponse);
    rpc GetCapabilities() returns (Capabilities);
}

message TakePictureRequest {
    int32 quality = 1;
    string format = 2;
}

message TakePictureResponse {
    bytes image_data = 1;
    int64 timestamp = 2;
}

message Capabilities {
    repeated string formats = 1;
    int32 max_resolution = 2;
}
```

### 6.2 服务端实现

```rust
// examples/camera_server.rs

use softbus_core::prelude::*;
use async_trait::async_trait;

// 实现服务trait（由IDL编译器生成）
pub struct CameraServiceImpl {
    device_id: DeviceId,
}

#[async_trait]
impl CameraService for CameraServiceImpl {
    async fn take_picture(&self, req: TakePictureRequest) -> Result<TakePictureResponse> {
        tracing::info!("Taking picture with quality: {}", req.quality);
        
        // 模拟拍照
        let image_data = vec![0xFF; 1024 * 100]; // 100KB假数据
        
        Ok(TakePictureResponse {
            image_data,
            timestamp: chrono::Utc::now().timestamp_millis(),
        })
    }
    
    async fn get_capabilities(&self) -> Result<Capabilities> {
        Ok(Capabilities {
            formats: vec!["jpeg".to_string(), "png".to_string()],
            max_resolution: 4096,
        })
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // 初始化日志
    tracing_subscriber::fmt::init();
    
    // 创建软总线实例
    let softbus = Softbus::new().await?;
    softbus.start().await?;
    
    // 创建服务实现
    let camera_service = Arc::new(CameraServiceImpl {
        device_id: softbus.device_id().clone(),
    });
    
    // 注册服务
    let stub = CameraServiceStub::new(camera_service);
    softbus.register_service(
        ServiceId::new("com.example.CameraService"),
        Box::new(stub),
    ).await?;
    
    tracing::info!("Camera service started");
    
    // 保持运行
    tokio::signal::ctrl_c().await?;
    Ok(())
}
```

### 6.3 客户端调用

```rust
// examples/camera_client.rs

use softbus_core::prelude::*;

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt::init();
    
    // 创建软总线实例
    let softbus = Softbus::new().await?;
    softbus.start().await?;
    
    // 发现相机服务
    let service_id = ServiceId::new("com.example.CameraService");
    let services = softbus.discover_service(&service_id).await?;
    
    if services.is_empty() {
        eprintln!("Camera service not found");
        return Ok(());
    }
    
    tracing::info!("Found {} camera services", services.len());
    
    // 创建代理
    let camera_proxy = CameraServiceProxy::new(softbus.router());
    
    // 调用远程方法
    let request = TakePictureRequest {
        quality: 95,
        format: "jpeg".to_string(),
    };
    
    tracing::info!("Taking picture...");
    let response = camera_proxy.take_picture(request).await?;
    
    tracing::info!(
        "Received image: {} bytes, timestamp: {}",
        response.image_data.len(),
        response.timestamp
    );
    
    // 保存图片
    std::fs::write("photo.jpg", &response.image_data)?;
    
    Ok(())
}
```

---

## 7. 编译与部署

### 7.1 构建Protobuf

```bash
# 安装protoc编译器
# Windows
choco install protoc

# Linux
sudo apt install protobuf-compiler

# 添加构建脚本
cat > softbus-core/build.rs << 'EOF'
fn main() {
    prost_build::compile_protos(&["proto/rpc.proto"], &["proto/"]).unwrap();
}
EOF
```

### 7.2 编译原生库（C/C++）

```bash
# Linux Wi-Fi Direct库
cd native/wifi
mkdir build && cd build
cmake ..
make

# 安装到系统
sudo make install

# 或复制到Rust项目
cp libwifi_direct.so ../../../target/debug/
```

### 7.3 编译整个项目

```bash
# 回到项目根目录
cd ../../..

# 构建所有模块
cargo build --workspace --release

# 运行测试
cargo test --workspace

# 生成文档
cargo doc --no-deps --open
```

### 7.4 交叉编译到Android

```bash
# 添加Android目标
rustup target add aarch64-linux-android

# 配置NDK路径
export ANDROID_NDK_HOME=/path/to/ndk

# 编译
cargo build --target aarch64-linux-android --release
```

---

## 8. 性能测试

### 8.1 延迟测试

```rust
// examples/bench_latency.rs

use softbus_core::prelude::*;
use std::time::Instant;

#[tokio::main]
async fn main() -> Result<()> {
    let softbus = Softbus::new().await?;
    softbus.start().await?;
    
    // 等待发现设备
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    let service_id = ServiceId::new("com.example.EchoService");
    let proxy = EchoServiceProxy::new(softbus.router());
    
    // 预热
    for _ in 0..10 {
        let _ = proxy.echo("warmup".to_string()).await;
    }
    
    // 测试100次往返延迟
    let mut latencies = Vec::new();
    
    for i in 0..100 {
        let start = Instant::now();
        let _ = proxy.echo(format!("test-{}", i)).await?;
        let latency = start.elapsed();
        
        latencies.push(latency);
    }
    
    // 统计
    let avg = latencies.iter().sum::<Duration>() / latencies.len() as u32;
    let min = latencies.iter().min().unwrap();
    let max = latencies.iter().max().unwrap();
    
    println!("Latency stats:");
    println!("  Average: {:?}", avg);
    println!("  Min: {:?}", min);
    println!("  Max: {:?}", max);
    
    Ok(())
}
```

### 8.2 吞吐量测试

```bash
# 使用iperf风格的测试
cargo run --example bench_throughput -- --duration 30 --payload-size 1024
```

---

## 9. 调试技巧

### 9.1 启用详细日志

```rust
// 设置环境变量
RUST_LOG=softbus=trace,tokio=debug cargo run

// 或在代码中
tracing_subscriber::fmt()
    .with_max_level(tracing::Level::TRACE)
    .init();
```

### 9.2 抓包分析

```bash
# Linux蓝牙抓包
sudo btmon

# Wi-Fi抓包
sudo tcpdump -i wlan0 -w softbus.pcap

# 使用Wireshark分析
wireshark softbus.pcap
```

### 9.3 性能分析

```bash
# 安装火焰图工具
cargo install flamegraph

# 生成火焰图
cargo flamegraph --example camera_server
```

---

**下一步**: 参见项目仓库中的完整示例代码和单元测试。
