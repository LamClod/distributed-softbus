# å¼€å‘å·¥ä½œæµä¸æœ€ä½³å®è·µ

## å¼€å‘ç¯å¢ƒè®¾ç½®

### 1. å®Œæ•´å·¥å…·é“¾å®‰è£…

```bash
# å®‰è£…Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env

# å®‰è£…é¢å¤–å·¥å…·
cargo install cargo-watch      # è‡ªåŠ¨é‡ç¼–è¯‘
cargo install cargo-edit       # ä¾èµ–ç®¡ç†
cargo install cargo-expand     # å®å±•å¼€
cargo install cargo-bloat      # äºŒè¿›åˆ¶å¤§å°åˆ†æ
cargo install cargo-audit      # å®‰å…¨å®¡è®¡
cargo install just             # ä»»åŠ¡è¿è¡Œå™¨

# å®‰è£…IDEæ’ä»¶ï¼ˆVS Codeï¼‰
code --install-extension rust-lang.rust-analyzer
code --install-extension vadimcn.vscode-lldb
code --install-extension serayuzgur.crates
```

### 2. é¡¹ç›®åˆå§‹åŒ–è„šæœ¬

```bash
#!/bin/bash
# scripts/init-dev.sh

set -e

echo "ğŸš€ Initializing development environment..."

# 1. å®‰è£…ç³»ç»Ÿä¾èµ–
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    sudo apt update
    sudo apt install -y \
        build-essential \
        pkg-config \
        libbluetooth-dev \
        libdbus-1-dev \
        cmake
elif [[ "$OSTYPE" == "darwin"* ]]; then
    brew install cmake pkg-config
fi

# 2. å®‰è£…Rustå·¥å…·é“¾
rustup component add clippy rustfmt
rustup target add x86_64-unknown-linux-gnu
rustup target add aarch64-linux-android

# 3. å®‰è£…Git hooks
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
cargo fmt --all -- --check
cargo clippy --all -- -D warnings
EOF
chmod +x .git/hooks/pre-commit

# 4. åˆ›å»ºæœ¬åœ°é…ç½®
cat > .env << EOF
RUST_LOG=softbus=debug
RUST_BACKTRACE=1
EOF

echo "âœ… Development environment ready!"
```

---

## æ—¥å¸¸å¼€å‘å·¥ä½œæµ

### æ–¹æ¡ˆA: ä½¿ç”¨ Justï¼ˆæ¨èï¼‰

```bash
# æŸ¥çœ‹æ‰€æœ‰å¯ç”¨ä»»åŠ¡
just --list

# å¼€å‘æ¨¡å¼ï¼ˆè‡ªåŠ¨é‡ç¼–è¯‘ï¼‰
just dev

# è¿è¡Œæµ‹è¯•
just test

# ä»£ç æ£€æŸ¥
just check

# å®Œæ•´CIæµç¨‹
just ci
```

**Justfileé…ç½®**:
```justfile
# é»˜è®¤ä»»åŠ¡
default:
    @just --list

# å¼€å‘æ¨¡å¼ï¼ˆè‡ªåŠ¨é‡ç¼–è¯‘å¹¶è¿è¡Œï¼‰
dev:
    cargo watch -x 'run --example camera-server'

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
test:
    cargo test --workspace --all-features

# ä»£ç æ ¼å¼åŒ–
fmt:
    cargo fmt --all

# Clippyæ£€æŸ¥
clippy:
    cargo clippy --workspace --all-features -- -D warnings

# å®Œæ•´CIæ£€æŸ¥
ci: fmt clippy test
    cargo build --workspace --release

# è¿è¡Œæ€§èƒ½æµ‹è¯•
bench:
    cargo bench --workspace

# æ¸…ç†æ„å»ºäº§ç‰©
clean:
    cargo clean
    rm -rf target/
```

### æ–¹æ¡ˆB: ä½¿ç”¨ Make

```makefile
.PHONY: all build test clean

all: build

build:
	cargo build --workspace

test:
	cargo test --workspace

dev:
	cargo watch -x 'run --example camera-server'

check:
	cargo fmt --all -- --check
	cargo clippy --workspace -- -D warnings

clean:
	cargo clean
```

---

## åŠŸèƒ½å¼€å‘æµç¨‹

### 1. åˆ›å»ºåŠŸèƒ½åˆ†æ”¯

```bash
# åŸºäºmainåˆ›å»ºåŠŸèƒ½åˆ†æ”¯
git checkout -b feature/wifi-direct-adapter

# æˆ–ä¿®å¤bug
git checkout -b fix/ble-connection-timeout
```

### 2. TDDå¼€å‘å¾ªç¯

```rust
// 1. å…ˆå†™æµ‹è¯•ï¼ˆtests/wifi_direct_test.rsï¼‰
#[tokio::test]
async fn test_wifi_direct_connection() {
    let adapter = WifiDirectAdapter::new().await.unwrap();
    adapter.start().await.unwrap();
    
    let devices = adapter.discover(Duration::from_secs(5)).await.unwrap();
    assert!(!devices.is_empty());
}

// 2. è¿è¡Œæµ‹è¯•ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
cargo test test_wifi_direct_connection

// 3. å®ç°åŠŸèƒ½ï¼ˆsrc/network/wifi/adapter.rsï¼‰
pub struct WifiDirectAdapter {
    // ...
}

impl WifiDirectAdapter {
    pub async fn new() -> Result<Self> {
        // å®ç°...
    }
}

// 4. è¿è¡Œæµ‹è¯•ï¼ˆåº”è¯¥é€šè¿‡ï¼‰
cargo test test_wifi_direct_connection

// 5. é‡æ„ä»£ç 
// 6. é‡å¤å¾ªç¯
```

### 3. æŒç»­æµ‹è¯•

```bash
# ç›‘è§†æ–‡ä»¶å˜åŒ–ï¼Œè‡ªåŠ¨è¿è¡Œæµ‹è¯•
cargo watch -x 'test -p softbus-network'

# åªæµ‹è¯•ç‰¹å®šæ¨¡å—
cargo watch -x 'test wifi_direct'

# æµ‹è¯•+ä»£ç è¦†ç›–ç‡
cargo watch -x tarpaulin
```

### 4. æäº¤ä»£ç 

```bash
# æ ¼å¼åŒ–ä»£ç 
cargo fmt --all

# è¿è¡ŒClippy
cargo clippy --all -- -D warnings

# æäº¤
git add .
git commit -m "feat(network): add Wi-Fi Direct adapter

- Implement device discovery via P2P
- Add connection establishment logic
- Include unit tests

Closes #123"

# æ¨é€
git push origin feature/wifi-direct-adapter
```

---

## ä»£ç é£æ ¼æŒ‡å—

### 1. Rustä»£ç è§„èŒƒ

```rust
// âœ… å¥½çš„å‘½å
pub struct ConnectionManager {
    channels: Arc<DashMap<DeviceId, Channel>>,
}

impl ConnectionManager {
    /// è·å–åˆ°æŒ‡å®šè®¾å¤‡çš„é€šé“
    /// 
    /// # Arguments
    /// * `device_id` - ç›®æ ‡è®¾å¤‡ID
    /// 
    /// # Returns
    /// æˆåŠŸè¿”å›é€šé“ï¼Œå¤±è´¥è¿”å›é”™è¯¯
    pub async fn get_channel(&self, device_id: &DeviceId) -> Result<Channel> {
        // å®ç°...
    }
}

// âŒ ä¸å¥½çš„å‘½å
pub struct CM {  // ç¼©å†™ä¸æ¸…æ™°
    ch: Arc<DashMap<String, C>>,  // ç±»å‹ä¸æ˜ç¡®
}
```

### 2. é”™è¯¯å¤„ç†

```rust
// âœ… ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ç±»å‹
#[derive(Error, Debug)]
pub enum NetworkError {
    #[error("Connection failed: {0}")]
    ConnectionFailed(String),
    
    #[error("Device not found: {device_id}")]
    DeviceNotFound { device_id: String },
}

// âœ… ä¼ æ’­é”™è¯¯
pub async fn connect(&self, id: &DeviceId) -> Result<Channel> {
    let adapter = self.get_adapter(id)?;
    adapter.connect(id).await
        .map_err(|e| NetworkError::ConnectionFailed(e.to_string()))
}

// âŒ åæ‰é”™è¯¯
pub async fn connect(&self, id: &DeviceId) -> Option<Channel> {
    self.get_adapter(id).ok()?.connect(id).await.ok()
}
```

### 3. å¼‚æ­¥ä»£ç 

```rust
// âœ… ä½¿ç”¨async/await
pub async fn send_data(&self, data: &[u8]) -> Result<()> {
    let channel = self.get_channel().await?;
    channel.send(data).await?;
    Ok(())
}

// âœ… å¹¶å‘å¤„ç†
use futures::future::join_all;

pub async fn broadcast(&self, data: &[u8]) -> Result<()> {
    let futures: Vec<_> = self.channels
        .iter()
        .map(|ch| ch.send(data))
        .collect();
    
    join_all(futures).await;
    Ok(())
}

// âŒ é˜»å¡è°ƒç”¨
pub fn send_data_blocking(&self, data: &[u8]) -> Result<()> {
    std::thread::sleep(Duration::from_secs(1));  // é˜»å¡ï¼
    Ok(())
}
```

### 4. ç”Ÿå‘½å‘¨æœŸä¸æ‰€æœ‰æƒ

```rust
// âœ… æ˜ç¡®ç”Ÿå‘½å‘¨æœŸ
pub struct ChannelRef<'a> {
    inner: &'a Channel,
}

impl<'a> ChannelRef<'a> {
    pub fn quality(&self) -> &LinkQuality {
        &self.inner.quality
    }
}

// âœ… ä½¿ç”¨Arcå…±äº«æ‰€æœ‰æƒ
pub struct SharedChannel {
    inner: Arc<Channel>,
}

impl Clone for SharedChannel {
    fn clone(&self) -> Self {
        Self {
            inner: Arc::clone(&self.inner),
        }
    }
}
```

---

## æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•

```rust
// src/service/registry.rs
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_service_registration() {
        let registry = ServiceRegistry::new();
        
        let metadata = ServiceMetadata {
            id: ServiceId::new("test.service"),
            name: "Test Service".to_string(),
            version: "1.0.0".to_string(),
            capabilities: vec![],
            provider: DeviceId::generate(),
        };
        
        assert!(registry.register(metadata.clone()).is_ok());
        assert_eq!(
            registry.get_local(&metadata.id).unwrap().name,
            "Test Service"
        );
    }
    
    #[tokio::test]
    async fn test_async_operation() {
        // å¼‚æ­¥æµ‹è¯•...
    }
}
```

### 2. é›†æˆæµ‹è¯•

```rust
// tests/integration_test.rs
use softbus_core::prelude::*;

#[tokio::test]
async fn test_end_to_end_rpc() {
    // å¯åŠ¨æœåŠ¡ç«¯
    let server_softbus = Softbus::new().await.unwrap();
    server_softbus.start().await.unwrap();
    
    let service = Arc::new(TestServiceImpl);
    server_softbus.register_service(
        ServiceId::new("test.service"),
        Box::new(TestServiceStub::new(service)),
    ).await.unwrap();
    
    // å¯åŠ¨å®¢æˆ·ç«¯
    let client_softbus = Softbus::new().await.unwrap();
    client_softbus.start().await.unwrap();
    
    // ç­‰å¾…å‘ç°
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    // è°ƒç”¨RPC
    let proxy = TestServiceProxy::new(client_softbus.router());
    let response = proxy.test_method(Request {
        data: "hello".to_string(),
    }).await.unwrap();
    
    assert_eq!(response.result, 42);
}
```

### 3. æ€§èƒ½æµ‹è¯•

```rust
// benches/rpc_bench.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn rpc_call_benchmark(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    c.bench_function("rpc_call_local", |b| {
        b.to_async(&rt).iter(|| async {
            let proxy = create_proxy();
            proxy.simple_call(black_box(Request::default())).await
        });
    });
}

criterion_group!(benches, rpc_call_benchmark);
criterion_main!(benches);
```

### 4. Mockæµ‹è¯•

```rust
// tests/mock_channel_test.rs
use mockall::predicate::*;
use mockall::*;

#[automock]
trait VirtualChannel {
    async fn send(&self, data: &[u8]) -> Result<usize>;
}

#[tokio::test]
async fn test_with_mock() {
    let mut mock_channel = MockVirtualChannel::new();
    
    mock_channel
        .expect_send()
        .with(eq(b"test"))
        .times(1)
        .returning(|_| Ok(4));
    
    let result = mock_channel.send(b"test").await;
    assert_eq!(result.unwrap(), 4);
}
```

---

## æ€§èƒ½åˆ†æå·¥ä½œæµ

### 1. CPUæ€§èƒ½åˆ†æ

```bash
# ä½¿ç”¨flamegraph
cargo install flamegraph
cargo flamegraph --example camera-server

# æˆ–ä½¿ç”¨perfï¼ˆLinuxï¼‰
perf record -g target/release/camera-server
perf report
```

### 2. å†…å­˜åˆ†æ

```bash
# ä½¿ç”¨valgrind
valgrind --tool=massif --massif-out-file=massif.out \
    target/release/camera-server

# å¯è§†åŒ–
ms_print massif.out

# æˆ–ä½¿ç”¨heaptrack
heaptrack target/release/camera-server
heaptrack_gui heaptrack.camera-server.*.gz
```

### 3. å¼‚æ­¥è¿è¡Œæ—¶åˆ†æ

```rust
// å¯ç”¨tokio-console
use console_subscriber;

#[tokio::main]
async fn main() {
    console_subscriber::init();
    
    // åº”ç”¨é€»è¾‘...
}
```

```bash
# å¦ä¸€ä¸ªç»ˆç«¯è¿è¡Œ
cargo install tokio-console
tokio-console
```

---

## CI/CDé…ç½®

### GitHub Actionsç¤ºä¾‹

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        rust: [stable, nightly]
    
    runs-on: ${{ matrix.os }}
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: ${{ matrix.rust }}
        override: true
        components: rustfmt, clippy
    
    - name: Cache
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Format check
      run: cargo fmt --all -- --check
    
    - name: Clippy
      run: cargo clippy --all -- -D warnings
    
    - name: Build
      run: cargo build --workspace --verbose
    
    - name: Test
      run: cargo test --workspace --verbose
    
    - name: Benchmark
      if: matrix.os == 'ubuntu-latest' && matrix.rust == 'stable'
      run: cargo bench --workspace

  coverage:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Install tarpaulin
      run: cargo install cargo-tarpaulin
    
    - name: Generate coverage
      run: cargo tarpaulin --workspace --out Xml --output-dir coverage
    
    - name: Upload to codecov
      uses: codecov/codecov-action@v3
      with:
        files: coverage/cobertura.xml
```

---

## ç‰ˆæœ¬å‘å¸ƒæµç¨‹

### 1. å‡†å¤‡å‘å¸ƒ

```bash
# æ›´æ–°ç‰ˆæœ¬å·
cargo set-version 0.2.0

# æ›´æ–°CHANGELOG.md
cat >> CHANGELOG.md << EOF
## [0.2.0] - 2024-12-01

### Added
- Wi-Fi Direct transport support
- Service health monitoring

### Fixed
- BLE connection timeout issue

### Changed
- Improved RPC performance by 30%
EOF

# æäº¤
git add .
git commit -m "chore: release v0.2.0"
git tag v0.2.0
```

### 2. å‘å¸ƒåˆ°crates.io

```bash
# å‘å¸ƒå„æ¨¡å—ï¼ˆæŒ‰ä¾èµ–é¡ºåºï¼‰
cargo publish -p softbus-core
cargo publish -p softbus-network
cargo publish -p softbus-idl-compiler

# æ¨é€æ ‡ç­¾
git push origin v0.2.0
```

### 3. åˆ›å»ºGitHub Release

```bash
# ä½¿ç”¨gh CLI
gh release create v0.2.0 \
    --title "v0.2.0 - Wi-Fi Direct Support" \
    --notes-file CHANGELOG.md \
    target/release/softbus-*
```

---

## è°ƒè¯•æŠ€å·§

### 1. LLDBè°ƒè¯•

```bash
# ç¼–è¯‘å¸¦è°ƒè¯•ç¬¦å·
cargo build

# å¯åŠ¨è°ƒè¯•å™¨
rust-lldb target/debug/camera-server

# è®¾ç½®æ–­ç‚¹
(lldb) b softbus_core::service::router::ServiceRouter::route_call
(lldb) run

# æŸ¥çœ‹å˜é‡
(lldb) frame variable
(lldb) p service_id
```

### 2. æ—¥å¿—è°ƒè¯•

```rust
use tracing::{debug, info, warn, error, instrument};

#[instrument(skip(self))]
pub async fn route_call(&self, service_id: &ServiceId) -> Result<Response> {
    info!("Routing call to service: {}", service_id);
    
    debug!("Looking up service in registry");
    let provider = self.registry.get_provider(service_id)?;
    
    debug!("Getting channel to device: {}", provider);
    let channel = self.conn_manager.get_channel(&provider).await?;
    
    info!("Call routed successfully");
    Ok(response)
}
```

```bash
# è¿è¡Œæ—¶æ§åˆ¶æ—¥å¿—çº§åˆ«
RUST_LOG=softbus_core::service=trace cargo run
```

### 3. ç½‘ç»œæŠ“åŒ…

```bash
# BLE
sudo btmon -w ble_capture.pcap

# TCP
sudo tcpdump -i any -w tcp_capture.pcap port 8888

# åˆ†æ
wireshark tcp_capture.pcap
```

---

**æœ€åæ›´æ–°**: 2024-11-28  
**é€‚ç”¨ç‰ˆæœ¬**: v0.1.0+
